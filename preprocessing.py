
'''
   This script assumes that you already have PROSTATEx datasets and transform files:
       - Download the image SimpleITK transform files:
       https://github.com/OscarPellicer/prostate_lesion_detection/blob/main/ProstateX_transforms.zip

       - Download the PROSTATEx challenge dataset:
       https://wiki.cancerimagingarchive.net/pages/viewpage.action?pageId=23691656

   Loading dicom and image registration steps are based on Oscar Pellicer's preprocessing script for prostateX
   https://github.com/OscarPellicer/prostate_lesion_detection/blob/main/preprocessing_lib.py


'''

import os
import SimpleITK as sitk
import numpy as np
import pandas as pd
from utils.preprocessing_lib import (join_sitk_images, join_masks, read_prostatex_patient,
                         resampling_operation,
                         get_lesion_mask_id_seed)

import h5py



def getBoundingBox(Image, MRvox_middle, xthr, ythr, zthr):
    bbx_start, bby_start, bbz_start = np.floor(MRvox_middle - np.array([xthr / 2, ythr / 2, zthr / 2])).astype(
        'int')
    if bbx_start < 0: bbx_start = 0
    if bby_start < 0: bby_start = 0
    if bbz_start < 0: bbz_start = 0
    if bbx_start + xthr > Image.shape[0]: bbx_start = Image.shape[0] - xthr
    if bby_start + ythr > Image.shape[1]: bby_start = Image.shape[1] - ythr
    if bbz_start + zthr > Image.shape[2]: bbz_start = Image.shape[2] - zthr

    return Image[bbx_start: (bbx_start + xthr), bby_start: (bby_start + ythr), bbz_start:(bbz_start + zthr)]

def h5_lesion_zero_check(h5name):
    hf = h5py.File(h5name, 'r')
    flag = np.array(hf['lesion']).sum() == 0
    hf.close()
    return flag


if __name__ == "__main__":
    #########################################################
    ## !! Change the directory names based on yours.
    #########################################################
    gpuserver = False
    if gpuserver:
        gpudir = '/share/sablab/'
    else:
        gpudir = ''

    #TRAIN is boolean indicating whether we are using the TRAIN or the TEST data of PROSTATEx dataset
    TRAIN= True
    # TRAIN= False

    #Path where you saved the downloaded mask and sitk transform files
    project_dir = '/home/hk672/prostate_lesion_detection_OscarPellicer/'
    #Path where DICOMS are stored
    dicom_path= gpudir+'/nfs04/data/PROSTATEx/manifest-A3Y4AE4o5818678569166032044/PROSTATEx/'
    orig_dir = dicom_path
    #Path where ktrans images are stored
    if TRAIN:
        ktrans_path= gpudir+'/nfs04/data/PROSTATEx/PROSTATEx/ProstateXKtrains-train-fixed' # train
    else:
        ktrans_path= gpudir+'/nfs04/data/PROSTATEx/PROSTATEx/ProstateXKtrans-test-fixedv2' # train

    #Path where csvs are stored
    if TRAIN:
        prostateX_csv_path= os.path.join(orig_dir+'/../../PROSTATEx/ProstateX-TrainingLesionInformationv2/',
                                        'ProstateX-Findings-%s.csv'%('Train' if TRAIN else 'Test'))
    else:
        prostateX_csv_path= os.path.join(orig_dir+'/../../PROSTATEx/ProstateX-TestLesionInformation//',
                                        'ProstateX-Findings-%s.csv'%('Train' if TRAIN else 'Test'))


    prostateX2_csv_path= os.path.join(orig_dir+'/../../PROSTATEx2/ProstateX2-DataInfo-%s'%('Train' if TRAIN else 'Test'),
                                     'ProstateX-2-Findings-%s.csv'%('Train' if TRAIN else 'Test'))

    #Path where you save preprocessed final h5 files.
    h5savedir = '/home/hk672/data-preprocessed/PROSTATEx-new/h5-prostate-patch-with-registration/'

    ###################
    #Main configuration
    ###################
    verbose= True #Show extra information during the process
    apply_registration= True #Use transformations in transforms_path to register the images
    patchx, patchy, patchz = [50, 46, 41]
    patchx2, patchy2, patchz2 = int(patchx*2), int(patchy*2), int(patchz*2) # twice the input patch size for image augmentation

    #2) Data provided alongside the repository:
    #Path to where ProstateX_masks are stored
    masks_path= f'{project_dir}/ProstateX_masks'
    lesion_mask_dir = orig_dir + '../..//PROSTATEx_masks-master/Files/'

    #Path where registration transformations are stored
    transforms_path= f'{project_dir}/ProstateX_transforms'

    #3) Output data to be generated by this Notebook:
    #Path where data to be read by the Retina UNet model will be stored
    #We create the directory if it did not exist
    output_path= '/home/hk672/data-preprocessed/PROSTATEx-new/h5-patch-with-registration/'
    if not os.path.exists(output_path): os.makedirs(output_path)

    #Read csvs
    l_info= pd.read_csv(prostateX_csv_path, index_col='ProxID')
    l_info_2= pd.read_csv(prostateX2_csv_path, index_col='ProxID')
    lesion_info= l_info.reset_index().merge(l_info_2.reset_index(), how="left",
                                            on=['ProxID', 'pos', 'zone', 'fid'])


    if TRAIN:
        lesion_info.loc[lesion_info.ggg.isna(), 'ggg']= 10
        lesion_info.ggg= lesion_info.ggg.astype(int)

    # lesion_info.head(10)

    demo_dir = '/home/hk672/biopsy-prediction/'

    IDs = np.unique(lesion_info.ProxID)

    # ## reset duplicated pids
    find_samefids = []
    flag = False
    for ID in IDs:  # [102:]
        fids = np.array(lesion_info.fid[lesion_info.ProxID == ID])
        for fid in fids:
            if np.where(fids == fid)[0].__len__() > 1:
                flag = True
                find_samefids.append(ID + f'_Finding{fid}')
        if flag:
            lesion_info.fid[lesion_info.ProxID == ID] = np.arange(len(fids))

    if TRAIN:
        lesion_info.to_csv('/home/hk672/data-preprocessed/PROSTATEx-new/prostateX-demo-csPCa-prediction-multimodal-sitk-newidx.csv')
    else:
        lesion_info.to_csv(
            '/home/hk672/data-preprocessed/PROSTATEx-test/prostateX-demo-csPCa-prediction-multimodal-sitk-newidx.csv')

    # For image synthesis purpose.
    # Label does not matter

    project_dir = '/home/hk672/prostate_lesion_detection_OscarPellicer/'
    # Path where registration transformations are stored
    transforms_path = f'{project_dir}/ProstateX_transforms'
    masks_path = f'{project_dir}/ProstateX_masks'

    apply_registration = True
    IDs = np.unique(lesion_info['ProxID'])
    for ID in IDs[86*3:]: #86

        h5fname = os.path.join(h5savedir, f'{ID}.h5')

        if not os.path.exists(h5fname):
            # Print patient ID
            print('\n%s' % ID)

            # Check if registration transform exists and load it
            if apply_registration and os.path.exists(os.path.join(transforms_path, ID + '.tfm')):
                transform = sitk.ReadTransform(os.path.join(transforms_path, ID + '.tfm'))
            else:
                transform = sitk.Euler3DTransform()
                print('No transform was found (or apply_registration is off). Image might be unregistered')

            # ---------------Read all images and masks, and then combine them---------------

            # Read all the modalities for a given ProstateX patient ID
            # There might be multiple directories (or not)
            patient_directories = os.listdir(os.path.join(dicom_path, ID))
            if len(patient_directories) != 1:
                print(' - Warning: Multiple directories!')

            patient_directories = patient_directories[0]
            images_path = os.path.join(dicom_path, ID, patient_directories)
            images_list = read_prostatex_patient(ID, images_path, ktrans_path, verbose=True)

            # Read Prostate segmentation mask
            mask = sitk.ReadImage(os.path.join(masks_path, ID + '_msk.nrrd'))

            # Read CZ segmentation mask
            cz_mask = sitk.ReadImage(os.path.join(masks_path, ID + '_cz_msk.nrrd'))

            # Add bfc to list of images
            img_final = join_sitk_images(images_list, resampler=sitk.sitkBSpline, cast_type=sitk.sitkFloat32)

            # Join all masks
            prostate_mask = join_masks(mask, cz_mask > 1.5, mode='append')

            # Load lesions information for current ID
            # load masks from publicly avaiable ProstateX masks
            ## -Use lesion provided by Cuocolo-
            # https://rcuocolo.github.io/PROSTATEx_masks/

            lesions = lesion_info[lesion_info.ProxID == ID].values
            positions = np.array([np.fromstring(p[2], dtype=np.float32, sep=' ') for p in lesions])

            print(' - Lesion positions and significances:')
            positions_img = np.array([images_list[0].TransformPhysicalPointToContinuousIndex(p.astype(np.float64))
                                      for p in positions])

            # We now create a small mask around the positions where lesions are located,
            # which will be used to find the location of lesions
            # the number in the image represents finding ID
            lesion_mask_id_seed = get_lesion_mask_id_seed(positions_img, mask)
            prostate_mask_intermediate = join_masks(prostate_mask, lesion_mask_id_seed, mode='append')

            img_backup = sitk.Image(img_final)
            img_array = sitk.GetArrayFromImage(img_final)
            img_final = sitk.GetImageFromArray(img_array, isVector=True)
            img_final.CopyInformation(img_backup)

            img_final_registered, mask_final = resampling_operation(img_final, prostate_mask_intermediate,
                                             spacing=(0.5, 0.5, 0.5), size='auto', transform=[],
                                             label_interpolator=sitk.sitkNearestNeighbor,
                                             transform_channels=[1, 2, 3], per_channel_transform=transform)

            ### --------------------------------
            ##!!! Check all fids: Some fids are gone after resampling based on its location!!!
            ### --------------------------------
            if not np.all(np.unique(sitk.GetArrayFromImage(sitk.VectorIndexSelectionCast(mask_final,2))) == \
                np.unique(sitk.GetArrayFromImage(sitk.VectorIndexSelectionCast(prostate_mask_intermediate,2)))):
                positions_img2 = np.array([sitk.VectorIndexSelectionCast(img_final_registered,0)\
                              .TransformPhysicalPointToContinuousIndex(p.astype(np.float64))
                              for p in positions])
                lesion_mask_id_seed_update = get_lesion_mask_id_seed(positions_img2, \
                                                             sitk.VectorIndexSelectionCast(mask_final,0))

                mask_backup = sitk.Image(mask_final)
                mask_array = sitk.GetArrayFromImage(mask_final)
                mask_array[:, :, :, 2] = sitk.GetArrayFromImage(lesion_mask_id_seed_update)
                mask_final = sitk.GetImageFromArray(mask_array, isVector=True)
                mask_final.CopyInformation(mask_backup)


            img_final_unregistered, _ = resampling_operation(img_final, prostate_mask_intermediate,
                                             spacing=(0.5, 0.5, 0.5), size='auto', transform=[],
                                             label_interpolator=sitk.sitkNearestNeighbor,
                                             transform_channels=[1, 2, 3], per_channel_transform=sitk.Euler3DTransform())

            img_final_registered_arr = sitk.GetArrayFromImage(img_final_registered).transpose(3, 2, 1, 0)[:, ::-1]
            img_final_unregistered_arr = sitk.GetArrayFromImage(img_final_unregistered).transpose(3, 2, 1, 0)[:, ::-1]
            prostate_mask_arr = sitk.GetArrayFromImage(mask_final).transpose(3, 2, 1, 0)[:, ::-1]

            if not os.path.exists( h5fname):
                prostate_middle_point = np.median(np.array(np.where(prostate_mask_arr[0]>0)), 1).astype('int')
                # update patchz2 if it is larger than image size
                if patchz2 > prostate_mask_arr.shape[-1]:
                    patchz2 = prostate_mask_arr.shape[-1]

                # img_final_registered_arr and img_final_unregistered_arr:
                # ['T2', 'b400', 'b800', 'ADC', 'ktrans']
                # prostate_mask_arr:
                # ['prostate', 'cz', 'lesion']

                hfnew = h5py.File(h5fname, 'w')
                hfnew.create_dataset('t2', data= \
                    getBoundingBox(img_final_unregistered_arr[0], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('dwib400', data= \
                    getBoundingBox(img_final_unregistered_arr[1], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('dwib800', data= \
                    getBoundingBox(img_final_unregistered_arr[2], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('adc', data= \
                    getBoundingBox(img_final_unregistered_arr[3], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('ktrans', data= \
                    getBoundingBox(img_final_unregistered_arr[4], prostate_middle_point, patchx2, patchy2, patchz2))


                hfnew.create_dataset('dwib400registered', data= \
                    getBoundingBox(img_final_registered_arr[1], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('dwib800registered', data= \
                    getBoundingBox(img_final_registered_arr[2], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('adcregistered', data= \
                    getBoundingBox(img_final_registered_arr[3], prostate_middle_point, patchx2, patchy2, patchz2))

                hfnew.create_dataset('prostate', data= \
                    getBoundingBox(prostate_mask_arr[0], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('cz', data= \
                    getBoundingBox(prostate_mask_arr[1], prostate_middle_point, patchx2, patchy2, patchz2))
                hfnew.create_dataset('pz', data= \
                    getBoundingBox(prostate_mask_arr[0]-prostate_mask_arr[1], prostate_middle_point, patchx2, patchy2, patchz2))

                hfnew.create_dataset('lesion', data= \
                    getBoundingBox(prostate_mask_arr[2], prostate_middle_point, patchx2, patchy2, patchz2))

                hfnew.create_dataset('patch-size', data=[patchx2, patchy2, patchz2])

                hfnew.close()

            del img_final_unregistered_arr
            del img_final_registered_arr
            del prostate_mask_arr

